use std::fs;
use std::path::Path;

fn main() {
    if std::env::var("CARGO_FEATURE_S3VECTORS_FDW").is_ok() {
        generate_s3vec_type_sql();
    }
}

/// Generates `s3vec_type_sql.rs` in OUT_DIR, which contains the `pgrx::extension_sql!` call
/// for the S3Vec type with the correct versioned library name embedded as a string literal.
///
/// This indirection is necessary because `pgrx::extension_sql!` requires a string literal
/// (not a macro expression like `concat!(env!(...), ...)`), but we need the library name
/// (e.g. "wrappers-0.6.0") to be derived from the crate version at compile time.
///
/// The generated file is included in `s3vec.rs` via:
///   `include!(concat!(env!("OUT_DIR"), "/s3vec_type_sql.rs"));`
fn generate_s3vec_type_sql() {
    let out_dir = std::env::var("OUT_DIR").expect("OUT_DIR not set");
    let pkg_name = std::env::var("CARGO_PKG_NAME").expect("CARGO_PKG_NAME not set");
    let pkg_version = std::env::var("CARGO_PKG_VERSION").expect("CARGO_PKG_VERSION not set");
    let lib_name = format!("{pkg_name}-{pkg_version}");

    // The outer r##"..."## delimiter allows r#"..."# to appear inside the format string.
    let content = format!(
        r##"// @generated by build.rs â€” do not edit by hand.
// Library name "{lib_name}" is embedded at compile time from CARGO_PKG_NAME/VERSION.
pgrx::extension_sql!(
    r#"DO $s3vec_upgrade$
BEGIN
    -- 1. Shell type (must exist before the in/out functions reference it)
    BEGIN
        CREATE TYPE S3Vec;
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;

    -- 2. Input function
    BEGIN
        CREATE FUNCTION "s3vec_in"("input" cstring)
            RETURNS S3Vec
            IMMUTABLE PARALLEL SAFE
            LANGUAGE c
            AS '{lib_name}', 's3vec_in_wrapper';
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;

    -- 3. Output function
    BEGIN
        CREATE FUNCTION "s3vec_out"("input" S3Vec)
            RETURNS cstring
            IMMUTABLE STRICT PARALLEL SAFE
            LANGUAGE c
            AS '{lib_name}', 's3vec_out_wrapper';
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;

    -- 4. Complete type definition (must come after in/out functions)
    BEGIN
        CREATE TYPE S3Vec (
            INTERNALLENGTH = variable,
            INPUT = s3vec_in,
            OUTPUT = s3vec_out,
            STORAGE = extended
        );
    EXCEPTION WHEN duplicate_object THEN NULL;
    END;
END
$s3vec_upgrade$;
"#,
    name = "s3vec_type",
    creates = [Type(S3Vec)],
);
"##
    );

    let out_path = Path::new(&out_dir).join("s3vec_type_sql.rs");
    fs::write(&out_path, content)
        .unwrap_or_else(|e| panic!("failed to write {}: {e}", out_path.display()));
}
